import pandas as pdimport numpy as npfrom datetime import datetime, timedeltaimport loggingclass RiskManager:    """Advanced risk management system for the Claude trading agent"""        def __init__(self, portfolio_value=1000000):        """Initialize the risk manager"""        self.logger = logging.getLogger('RiskManager')        self.portfolio_value = portfolio_value                # Risk parameters        self.params = {            # Position sizing            "max_position_size": 0.02,      # Maximum 2% of portfolio per position            "max_sector_exposure": 0.20,    # Maximum 20% exposure to any sector            "max_market_exposure": 0.60,    # Maximum 60% exposure to the market                        # Stop loss settings            "fixed_stop_loss": 0.03,        # Fixed 3% stop loss            "atr_multiplier": 2.0,          # ATR-based stop loss (2x ATR)                        # Volatility-based adjustments            "high_volatility_threshold": 0.20,  # Annual volatility threshold            "volatility_position_reduction": 0.5, # Reduce position by 50% in high volatility                        # Market condition adjustments            "bearish_threshold": -0.05,     # Market down 5% is bearish            "bearish_exposure_reduction": 0.5, # Reduce exposure by 50% in bearish markets                        # Drawdown protection            "max_daily_loss": 0.015,        # Stop trading after 1.5% daily loss            "max_drawdown": 0.10,           # Take defensive action at 10% drawdown                        # Correlation limits            "max_correlation": 0.7,         # Limit exposure to correlated assets        }                # Internal state        self.daily_pnl = 0        self.portfolio_peak = portfolio_value        self.holdings = {}        self.sector_exposure = {}        self.market_state = "neutral"        self.volatility_regime = "normal"        self.correlated_pairs = {}        def update_market_state(self, nifty_data):        """Update market state based on Nifty 50 data"""        try:            # Calculate returns            nifty_returns = nifty_data['close'].pct_change()                        # Calculate SMA crossovers            sma_50 = nifty_data['close'].rolling(window=50).mean()            sma_200 = nifty_data['close'].rolling(window=200).mean()                        # Determine market state            latest_close = nifty_data['close'].iloc[-1]            latest_sma_50 = sma_50.iloc[-1]            latest_sma_200 = sma_200.iloc[-1]                        # 20-day return            returns_20d = nifty_data['close'].pct_change(20).iloc[-1]                        # Volatility (20-day)            volatility_20d = nifty_returns.rolling(window=20).std().iloc[-1] * (252 ** 0.5)                        # Update market state            if latest_sma_50 > latest_sma_200 and returns_20d > 0:                self.market_state = "bullish"            elif latest_sma_50 < latest_sma_200 and returns_20d < self.params["bearish_threshold"]:                self.market_state = "bearish"            else:                self.market_state = "neutral"                            # Update volatility regime            if volatility_20d > self.params["high_volatility_threshold"]:                self.volatility_regime = "high"            else:                self.volatility_regime = "normal"                            self.logger.info(f"Market state updated: {self.market_state}, Volatility: {self.volatility_regime}")            return True                    except Exception as e:            self.logger.error(f"Error updating market state: {e}")            return False        def calculate_position_size(self, symbol, analysis, market_data):        """Calculate the optimal position size for a trade"""        try:            # Get base position size from analysis (already capped at max_position_size)            base_position_size = min(                float(analysis.get('position_size', 0)),                 self.params["max_position_size"]            )                        # Adjust based on market state            if self.market_state == "bearish":                base_position_size *= self.params["bearish_exposure_reduction"]                        # Adjust based on volatility            if self.volatility_regime == "high":                base_position_size *= self.params["volatility_position_reduction"]                        # Adjust based on sector exposure            sector = self._get_sector(symbol)            current_sector_exposure = self.sector_exposure.get(sector, 0)            if current_sector_exposure >= self.params["max_sector_exposure"]:                self.logger.info(f"Sector exposure limit reached for {sector}: {current_sector_exposure:.2%}")                return 0                        # Adjust based on current drawdown            current_drawdown = 1 - (self.portfolio_value / self.portfolio_peak)            if current_drawdown >= self.params["max_drawdown"]:                # Severe drawdown - reduce position size                drawdown_factor = 1 - (current_drawdown / self.params["max_drawdown"])                base_position_size *= max(0.25, drawdown_factor)  # At least 25% reduction                        # Adjust based on correlation with existing holdings            correlation_factor = self._calculate_correlation_factor(symbol, market_data)            base_position_size *= correlation_factor                        # Ensure position size doesn't exceed remaining sector capacity            remaining_sector_capacity = self.params["max_sector_exposure"] - current_sector_exposure            sector_adjusted_size = min(base_position_size, remaining_sector_capacity)                        # Ensure we don't exceed max market exposure            current_total_exposure = sum(self.holdings.values())            remaining_exposure = max(0, self.params["max_market_exposure"] - current_total_exposure)                        final_position_size = min(sector_adjusted_size, remaining_exposure)                        self.logger.info(f"Position size for {symbol}: {final_position_size:.2%} of portfolio")            return final_position_size                    except Exception as e:            self.logger.error(f"Error calculating position size for {symbol}: {e}")            return 0        def calculate_stop_loss(self, symbol, entry_price, historical_data):        """Calculate appropriate stop loss level"""        try:            # Method 1: Fixed percentage            fixed_stop = entry_price * (1 - self.params["fixed_stop_loss"])                        # Method 2: ATR-based (Average True Range)            atr = self._calculate_atr(historical_data, 14)            atr_stop = entry_price - (atr * self.params["atr_multiplier"])                        # Method 3: Recent swing low (last 10 days)            recent_low = historical_data['low'].tail(10).min()                        # Take the highest (most conservative) of the three            stop_loss = max(fixed_stop, atr_stop, recent_low * 0.99)                        self.logger.info(f"Stop loss for {symbol}: {stop_loss:.2f} (Entry: {entry_price:.2f})")            return stop_loss                    except Exception as e:            self.logger.error(f"Error calculating stop loss for {symbol}: {e}")            return entry_price * (1 - self.params["fixed_stop_loss"])        def calculate_take_profit(self, symbol, entry_price, stop_loss):        """Calculate take profit level based on risk:reward ratio"""        try:            # Calculate risk in points            risk_points = entry_price - stop_loss                        # Use a 1:2 risk-reward ratio as default            take_profit = entry_price + (risk_points * 2)                        self.logger.info(f"Take profit for {symbol}: {take_profit:.2f} (Entry: {entry_price:.2f})")            return take_profit                    except Exception as e:            self.logger.error(f"Error calculating take profit for {symbol}: {e}")            return entry_price * 1.06  # Default 6% take profit        def update_portfolio(self, portfolio):        """Update internal portfolio state"""        try:            self.holdings = {}            self.sector_exposure = {}            total_value = 0                        # Calculate total portfolio value and exposures            for symbol, position in portfolio.items():                position_value = position["quantity"] * position["last_price"]                total_value += position_value                                # Update sector exposure                sector = self._get_sector(symbol)                if sector not in self.sector_exposure:                    self.sector_exposure[sector] = 0                self.sector_exposure[sector] += position_value                        # Update portfolio value            self.portfolio_value = total_value                        # Update peak value if needed            if total_value > self.portfolio_peak:                self.portfolio_peak = total_value                        # Convert to percentages            for symbol, position in portfolio.items():                position_value = position["quantity"] * position["last_price"]                self.holdings[symbol] = position_value / total_value if total_value > 0 else 0                        for sector in self.sector_exposure:                self.sector_exposure[sector] = self.sector_exposure[sector] / total_value if total_value > 0 else 0                        self.logger.info(f"Portfolio updated: ₹{total_value:,.2f}, Holdings: {len(self.holdings)}")            return True                    except Exception as e:            self.logger.error(f"Error updating portfolio: {e}")            return False        def update_daily_pnl(self, pnl):        """Update daily P&L and check if max loss is reached"""        self.daily_pnl = pnl        if pnl <= -self.portfolio_value * self.params["max_daily_loss"]:            self.logger.warning(f"Maximum daily loss reached: ₹{pnl:,.2f}")            return False  # Stop trading        return True  # Continue trading        def check_correlation(self, symbol1, symbol2, historical_data):        """Check correlation between two stocks"""        if f"{symbol1}:{symbol2}" in self.correlated_pairs:            return self.correlated_pairs[f"{symbol1}:{symbol2}"]                try:            # Extract closing prices            if symbol1 in historical_data and symbol2 in historical_data:                prices1 = historical_data[symbol1]['close']                prices2 = historical_data[symbol2]['close']                                # Calculate correlation on returns                returns1 = prices1.pct_change().dropna()                returns2 = prices2.pct_change().dropna()                                # Ensure same length                min_length = min(len(returns1), len(returns2))                correlation = returns1[-min_length:].corr(returns2[-min_length:])                                # Store result                self.correlated_pairs[f"{symbol1}:{symbol2}"] = correlation                self.correlated_pairs[f"{symbol2}:{symbol1}"] = correlation                                return correlation        except Exception as e:            self.logger.error(f"Error calculating correlation between {symbol1} and {symbol2}: {e}")                return 0  # Default to no correlation        def _get_sector(self, symbol):        """Get sector for a symbol (simplified implementation)"""        # In a real implementation, this would use a proper sector mapping        # Placeholder mapping for common Nifty 50 stocks        sector_map = {            "RELIANCE": "Energy",            "TCS": "IT",            "INFY": "IT",            "HDFCBANK": "Banking",            "ICICIBANK": "Banking",            "SBIN": "Banking",            "HINDUNILVR": "FMCG",            "ITC": "FMCG",            "BRITANNIA": "FMCG",            "SUNPHARMA": "Pharma",            "CIPLA": "Pharma",            "DRREDDY": "Pharma",        }                return sector_map.get(symbol, "Other")        def _calculate_atr(self, data, period=14):        """Calculate Average True Range"""        high = data['high']        low = data['low']        close = data['close']                tr1 = high - low        tr2 = abs(high - close.shift())        tr3 = abs(low - close.shift())                tr = pd.DataFrame({'tr1': tr1, 'tr2': tr2, 'tr3': tr3}).max(axis=1)        atr = tr.rolling(window=period).mean().iloc[-1]                return atr        def _calculate_correlation_factor(self, symbol, market_data):        """Calculate position size adjustment based on correlation with existing holdings"""        if not self.holdings:            return 1.0  # No holdings, no correlation adjustment                weighted_correlation = 0        total_weight = 0                for existing_symbol, weight in self.holdings.items():            correlation = self.check_correlation(                symbol, existing_symbol, market_data            )                        if abs(correlation) > self.params["max_correlation"]:                weighted_correlation += abs(correlation) * weight                total_weight += weight                if total_weight == 0:            return 1.0                    avg_correlation = weighted_correlation / total_weight                if avg_correlation > self.params["max_correlation"]:            # Reduce position size based on correlation            reduction_factor = 1.0 - ((avg_correlation - self.params["max_correlation"]) /                                     (1.0 - self.params["max_correlation"]))            return max(0.25, reduction_factor)  # At least 25% of original size                    return 1.0  # No reduction needed