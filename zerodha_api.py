import requestsimport jsonimport timeimport loggingimport pandas as pdfrom datetime import datetime, timedeltaclass ZerodhaClient:    """Client for interacting with Zerodha's API using enctoken authentication"""        def __init__(self, enctoken, user_id=None):        """        Initialize the Zerodha client                Parameters:        - enctoken: Authentication token from Zerodha Kite        - user_id: Zerodha user ID (optional, will be fetched if not provided)        """        self.enctoken = enctoken        self.user_id = user_id        self.kite_url = "https://api.kite.trade"        self.headers = {            "Authorization": f"enctoken {self.enctoken}",            "X-Kite-Version": "3",            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36"        }                # Set up logging        self.logger = logging.getLogger('ZerodhaClient')                # Cached data        self.instruments = None        self.margins = None        self.orders = []        self.positions = {}        self.holdings = {}                # Initialize client by verifying token and getting profile        self.profile = self.get_profile()        def get_profile(self):        """Get user profile and verify connection"""        try:            profile_url = f"{self.kite_url}/user/profile"            response = requests.get(profile_url, headers=self.headers)                        if response.status_code == 200:                profile_data = response.json()["data"]                self.user_id = profile_data["user_id"]                self.logger.info(f"Successfully connected to Zerodha as {self.user_id}")                return profile_data            else:                self.logger.error(f"Failed to get profile. Status: {response.status_code}")                self.logger.error(f"Response: {response.text}")                return None                        except Exception as e:            self.logger.error(f"Error getting profile: {e}")            return None        def get_margins(self):        """Get available margins"""        try:            margins_url = f"{self.kite_url}/user/margins"            response = requests.get(margins_url, headers=self.headers)                        if response.status_code == 200:                self.margins = response.json()["data"]                return self.margins            else:                self.logger.error(f"Failed to get margins. Status: {response.status_code}")                return None                        except Exception as e:            self.logger.error(f"Error getting margins: {e}")            return None        def get_instruments(self, exchange="NSE"):        """Get list of all instruments"""        try:            if self.instruments is not None:                # Return cached instruments for the requested exchange                return [instr for instr in self.instruments if instr["exchange"] == exchange]                        instruments_url = f"{self.kite_url}/instruments"            response = requests.get(instruments_url, headers=self.headers)                        if response.status_code == 200:                # Parse CSV response                lines = response.text.strip().split("\n")                headers = lines[0].split(",")                                instruments = []                for line in lines[1:]:                    values = line.split(",")                    instrument = {headers[i]: values[i] for i in range(len(headers))}                    instruments.append(instrument)                                self.instruments = instruments                                # Return only the requested exchange                return [instr for instr in instruments if instr["exchange"] == exchange]            else:                self.logger.error(f"Failed to fetch instruments. Status: {response.status_code}")                return []                        except Exception as e:            self.logger.error(f"Error getting instruments: {e}")            return []        def get_quotes(self, symbols):        """        Get current market quotes for given symbols                Parameters:        - symbols: List of symbols (e.g., ["RELIANCE", "TCS"])        """        try:            # Convert symbols to "NSE:SYMBOL" format            instruments = [f"NSE:{symbol}" for symbol in symbols]                        # Split into chunks of 100 (Zerodha API limit)            chunks = [instruments[i:i + 100] for i in range(0, len(instruments), 100)]                        all_quotes = {}                        for chunk in chunks:                quote_url = f"{self.kite_url}/quote"                params = {"i": chunk}                response = requests.get(quote_url, headers=self.headers, params=params)                                if response.status_code == 200:                    data = response.json()["data"]                                        for instrument, quote in data.items():                        symbol = instrument.split(":")[1]                        all_quotes[symbol] = quote                else:                    self.logger.error(f"Failed to fetch quotes. Status: {response.status_code}")                        return all_quotes                    except Exception as e:            self.logger.error(f"Error getting quotes: {e}")            return {}        def get_historical_data(self, instrument_token, interval="day", from_date=None, to_date=None, continuous=0, oi=0):        """        Get historical OHLC data                Parameters:        - instrument_token: Zerodha instrument token        - interval: Candle interval ("minute", "day", "3minute", etc.)        - from_date: Start date (default: 30 days ago)        - to_date: End date (default: today)        - continuous: Is continuous contract (for futures)        - oi: Include open interest        """        try:            if from_date is None:                from_date = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d")                        if to_date is None:                to_date = datetime.now().strftime("%Y-%m-%d")                            historical_url = f"{self.kite_url}/instruments/historical/{instrument_token}/{interval}"            params = {                "from": from_date,                "to": to_date,                "continuous": continuous,                "oi": oi            }                        response = requests.get(historical_url, headers=self.headers, params=params)                        if response.status_code == 200:                data = response.json()["data"]["candles"]                                # Convert to DataFrame                df = pd.DataFrame(data, columns=["date", "open", "high", "low", "close", "volume"])                df["date"] = pd.to_datetime(df["date"])                df.set_index("date", inplace=True)                                return df            else:                self.logger.error(f"Failed to fetch historical data. Status: {response.status_code}")                self.logger.error(f"Response: {response.text}")                return None                        except Exception as e:            self.logger.error(f"Error getting historical data: {e}")            return None        def get_positions(self):        """Get current day and net positions"""        try:            positions_url = f"{self.kite_url}/portfolio/positions"            response = requests.get(positions_url, headers=self.headers)                        if response.status_code == 200:                self.positions = response.json()["data"]                return self.positions            else:                self.logger.error(f"Failed to fetch positions. Status: {response.status_code}")                return None                        except Exception as e:            self.logger.error(f"Error getting positions: {e}")            return None        def get_holdings(self):        """Get holdings/investments"""        try:            holdings_url = f"{self.kite_url}/portfolio/holdings"            response = requests.get(holdings_url, headers=self.headers)                        if response.status_code == 200:                holdings_data = response.json()["data"]                                # Format holdings for easier access                formatted_holdings = {}                for holding in holdings_data:                    symbol = holding["tradingsymbol"]                    formatted_holdings[symbol] = {                        "quantity": holding["quantity"],                        "average_price": holding["average_price"],                        "last_price": holding["last_price"],                        "pnl": holding["pnl"],                        "day_change": holding["day_change"],                        "day_change_percentage": holding["day_change_percentage"]                    }                                self.holdings = formatted_holdings                return formatted_holdings            else:                self.logger.error(f"Failed to fetch holdings. Status: {response.status_code}")                return {}                        except Exception as e:            self.logger.error(f"Error getting holdings: {e}")            return {}        def get_orders(self):        """Get today's orders"""        try:            orders_url = f"{self.kite_url}/orders"            response = requests.get(orders_url, headers=self.headers)                        if response.status_code == 200:                self.orders = response.json()["data"]                return self.orders            else:                self.logger.error(f"Failed to fetch orders. Status: {response.status_code}")                return []                        except Exception as e:            self.logger.error(f"Error getting orders: {e}")            return []        def place_order(self, tradingsymbol, exchange="NSE", transaction_type="BUY",                     quantity=1, product="CNC", order_type="MARKET", price=0,                     validity="DAY", disclosed_quantity=0, trigger_price=0,                    squareoff=0, stoploss=0, trailing_stoploss=0, tag=""):        """        Place an order                Parameters:        - tradingsymbol: Trading symbol (e.g., "RELIANCE")        - exchange: Exchange (default: "NSE")        - transaction_type: "BUY" or "SELL"        - quantity: Order quantity        - product: "CNC" (delivery), "MIS" (intraday), etc.        - order_type: "MARKET", "LIMIT", "SL", "SL-M"        - price: Order price (for LIMIT orders)        - validity: "DAY" or "IOC"        - disclosed_quantity: Disclosed quantity        - trigger_price: Trigger price (for SL orders)        - squareoff: Square off value (for bracket orders)        - stoploss: Stoploss value (for bracket orders)        - trailing_stoploss: Trailing stoploss value (for bracket orders)        - tag: Additional tag for the order        """        try:            self.logger.info(f"Placing order: {transaction_type} {quantity} {tradingsymbol}")                        order_url = f"{self.kite_url}/orders/regular"                        payload = {                "exchange": exchange,                "tradingsymbol": tradingsymbol,                "transaction_type": transaction_type,                "quantity": quantity,                "product": product,                "order_type": order_type,                "validity": validity,                "tag": tag            }                        # Add conditional parameters            if order_type in ["LIMIT", "SL"]:                payload["price"] = price                        if order_type in ["SL", "SL-M"]:                payload["trigger_price"] = trigger_price                        if disclosed_quantity > 0:                payload["disclosed_quantity"] = disclosed_quantity                        self.logger.info(f"Order payload: {payload}")                        # Uncomment below to actually place the order            # response = requests.post(order_url, headers=self.headers, data=payload)            #             # if response.status_code == 200:            #     order_id = response.json()["data"]["order_id"]            #     self.logger.info(f"Order placed successfully. Order ID: {order_id}")            #     return {"status": "success", "order_id": order_id}            # else:            #     self.logger.error(f"Failed to place order. Status: {response.status_code}")            #     self.logger.error(f"Response: {response.text}")            #     return {"status": "failed", "error": response.text}                        # For simulation purposes            order_id = f"SIM-{int(time.time())}"            self.logger.info(f"SIMULATION: Order placed. Order ID: {order_id}")            return {"status": "simulation", "order_id": order_id}                        except Exception as e:            self.logger.error(f"Error placing order: {e}")            return {"status": "error", "error": str(e)}        def modify_order(self, order_id, quantity=None, price=None,                     order_type=None, trigger_price=None,                    validity=None, disclosed_quantity=None):        """        Modify an existing order                Parameters:        - order_id: ID of the order to modify        - Other parameters: Same as place_order        """        try:            self.logger.info(f"Modifying order: {order_id}")                        modify_url = f"{self.kite_url}/orders/{order_id}"                        payload = {}                        # Add parameters only if they are provided            if quantity is not None:                payload["quantity"] = quantity                            if price is not None:                payload["price"] = price                            if order_type is not None:                payload["order_type"] = order_type                            if trigger_price is not None:                payload["trigger_price"] = trigger_price                            if validity is not None:                payload["validity"] = validity                            if disclosed_quantity is not None:                payload["disclosed_quantity"] = disclosed_quantity                        self.logger.info(f"Modify payload: {payload}")                        # Uncomment below to actually modify the order            # response = requests.put(modify_url, headers=self.headers, data=payload)            #             # if response.status_code == 200:            #     order_id = response.json()["data"]["order_id"]            #     self.logger.info(f"Order modified successfully. Order ID: {order_id}")            #     return {"status": "success", "order_id": order_id}            # else:            #     self.logger.error(f"Failed to modify order. Status: {response.status_code}")            #     self.logger.error(f"Response: {response.text}")            #     return {"status": "failed", "error": response.text}                        # For simulation purposes            self.logger.info(f"SIMULATION: Order modified. Order ID: {order_id}")            return {"status": "simulation", "order_id": order_id}                        except Exception as e:            self.logger.error(f"Error modifying order: {e}")            return {"status": "error", "error": str(e)}        def cancel_order(self, order_id):        """        Cancel an order                Parameters:        - order_id: ID of the order to cancel        """        try:            self.logger.info(f"Cancelling order: {order_id}")                        cancel_url = f"{self.kite_url}/orders/{order_id}"                        # Uncomment below to actually cancel the order            # response = requests.delete(cancel_url, headers=self.headers)            #             # if response.status_code == 200:            #     self.logger.info(f"Order cancelled successfully. Order ID: {order_id}")            #     return {"status": "success", "order_id": order_id}            # else:            #     self.logger.error(f"Failed to cancel order. Status: {response.status_code}")            #     self.logger.error(f"Response: {response.text}")            #     return {"status": "failed", "error": response.text}                        # For simulation purposes            self.logger.info(f"SIMULATION: Order cancelled. Order ID: {order_id}")            return {"status": "simulation", "order_id": order_id}                        except Exception as e:            self.logger.error(f"Error cancelling order: {e}")            return {"status": "error", "error": str(e)}        def order_history(self, order_id):        """        Get history of an order                Parameters:        - order_id: ID of the order        """        try:            history_url = f"{self.kite_url}/orders/{order_id}"            response = requests.get(history_url, headers=self.headers)                        if response.status_code == 200:                history = response.json()["data"]                return history            else:                self.logger.error(f"Failed to fetch order history. Status: {response.status_code}")                return None                        except Exception as e:            self.logger.error(f"Error getting order history: {e}")            return None        def get_gtt_triggers(self):        """Get all GTT (Good Till Triggered) orders"""        try:            gtt_url = f"{self.kite_url}/gtt/triggers"            response = requests.get(gtt_url, headers=self.headers)                        if response.status_code == 200:                triggers = response.json()["data"]                return triggers            else:                self.logger.error(f"Failed to fetch GTT triggers. Status: {response.status_code}")                return []                        except Exception as e:            self.logger.error(f"Error getting GTT triggers: {e}")            return []        def place_gtt(self, tradingsymbol, exchange="NSE",                  trigger_type="single", trigger_values=None,                  last_price=0, orders=None):        """        Place a GTT (Good Till Triggered) order                Parameters:        - tradingsymbol: Trading symbol        - exchange: Exchange        - trigger_type: "single" or "two-leg"        - trigger_values: List of trigger prices        - last_price: Last price of the instrument        - orders: List of orders to execute when triggered        """        try:            if trigger_values is None:                trigger_values = []                            if orders is None:                orders = []                            self.logger.info(f"Placing GTT for {tradingsymbol}")                        gtt_url = f"{self.kite_url}/gtt/triggers"                        payload = {                "trigger_type": trigger_type,                "exchange": exchange,                "tradingsymbol": tradingsymbol,                "trigger_values": trigger_values,                "last_price": last_price,                "orders": orders            }                        self.logger.info(f"GTT payload: {payload}")                        # Uncomment below to actually place the GTT            # response = requests.post(gtt_url, headers=self.headers, json=payload)            #             # if response.status_code == 200:            #     trigger_id = response.json()["data"]["trigger_id"]            #     self.logger.info(f"GTT placed successfully. Trigger ID: {trigger_id}")            #     return {"status": "success", "trigger_id": trigger_id}            # else:            #     self.logger.error(f"Failed to place GTT. Status: {response.status_code}")            #     self.logger.error(f"Response: {response.text}")            #     return {"status": "failed", "error": response.text}                        # For simulation purposes            trigger_id = f"SIM-GTT-{int(time.time())}"            self.logger.info(f"SIMULATION: GTT placed. Trigger ID: {trigger_id}")            return {"status": "simulation", "trigger_id": trigger_id}                        except Exception as e:            self.logger.error(f"Error placing GTT: {e}")            return {"status": "error", "error": str(e)}        def find_instrument_token(self, symbol, exchange="NSE"):        """Find instrument token for a symbol"""        try:            instruments = self.get_instruments(exchange)            for instrument in instruments:                if instrument["tradingsymbol"] == symbol and instrument["exchange"] == exchange:                    return instrument["instrument_token"]                        self.logger.warning(f"Instrument token not found for {symbol}")            return None                    except Exception as e:            self.logger.error(f"Error finding instrument token: {e}")            return None        def place_stoploss_takeprofit(self, symbol, position_type, entry_price,                                  stop_loss, take_profit, quantity):        """        Place stop loss and take profit orders for a position                Parameters:        - symbol: Trading symbol        - position_type: "BUY" or "SELL"        - entry_price: Entry price of the position        - stop_loss: Stop loss price        - take_profit: Take profit price        - quantity: Quantity of shares        """        try:            self.logger.info(f"Setting SL/TP for {symbol} {position_type} position")                        # Determine transaction type for SL/TP orders            transaction_type = "SELL" if position_type == "BUY" else "BUY"                        # Place stop loss order            sl_result = self.place_order(                tradingsymbol=symbol,                transaction_type=transaction_type,                quantity=quantity,                product="CNC",  # For delivery                order_type="SL",                price=stop_loss,  # The price at which the order will be executed                trigger_price=stop_loss,  # The price at which the order will be triggered                tag="STOPLOSS"            )                        # Place take profit order            tp_result = self.place_order(                tradingsymbol=symbol,                transaction_type=transaction_type,                quantity=quantity,                product="CNC",  # For delivery                order_type="LIMIT",                price=take_profit,                tag="TAKEPROFIT"            )                        return {                "stop_loss_order": sl_result,                "take_profit_order": tp_result            }                    except Exception as e:            self.logger.error(f"Error placing SL/TP orders: {e}")            return {                "stop_loss_order": {"status": "error", "error": str(e)},                "take_profit_order": {"status": "error", "error": str(e)}            }        def refresh_enctoken(self, user_id, password, totp_secret=None):        """        Refresh enctoken using credentials                Note: This is a placeholder. In practice, you would need to implement        something like browser automation using Selenium to get a new token.                Parameters:        - user_id: Zerodha user ID        - password: Zerodha password        - totp_secret: TOTP secret for 2FA        """        try:            self.logger.info(f"Attempting to refresh enctoken for {user_id}")                        # This is just a placeholder - actual implementation would require            # browser automation or other methods to get a new token            self.logger.warning("refresh_enctoken is not implemented - just a placeholder")                        return self.enctoken                    except Exception as e:            self.logger.error(f"Error refreshing enctoken: {e}")            return None