import pandas as pdimport numpy as npimport requestsfrom datetime import datetime, timedeltaimport loggingclass MarketContextAnalyzer:    """Analyzes market context and sentiment for better trading decisions"""        def __init__(self):        """Initialize the market context analyzer"""        self.logger = logging.getLogger('MarketContextAnalyzer')        self.nifty_data = None        self.banknifty_data = None        self.vix_data = None        self.sector_performance = {}        self.global_indices = {}        self.fx_rates = {}        self.commodities = {}        self.headlines = []        self.economic_calendar = []                # Market state info        self.market_state = {            "overall": "neutral",            "trend": "neutral",            "volatility": "normal",            "breadth": "neutral",            "sentiment": "neutral",            "liquidity": "normal",            "global_influence": "neutral"        }        def fetch_index_data(self, index_codes=["NIFTY 50", "NIFTY BANK", "INDIA VIX"]):        """Fetch data for key indices"""        try:            self.logger.info(f"Fetching data for indices: {index_codes}")                        # In a real implementation, you would use your data provider API            # This is a placeholder for the implementation            for index in index_codes:                if index == "NIFTY 50":                    # Placeholder for actual API call                    self.nifty_data = self._generate_placeholder_index_data(index)                elif index == "NIFTY BANK":                    self.banknifty_data = self._generate_placeholder_index_data(index)                elif index == "INDIA VIX":                    self.vix_data = self._generate_placeholder_index_data(index)                        return True                    except Exception as e:            self.logger.error(f"Error fetching index data: {e}")            return False        def fetch_sector_performance(self):        """Fetch performance of key sectors"""        try:            self.logger.info("Fetching sector performance data")                        # Placeholder sectors            sectors = [                "NIFTY AUTO", "NIFTY BANK", "NIFTY FMCG", "NIFTY IT",                 "NIFTY METAL", "NIFTY PHARMA", "NIFTY REALTY"            ]                        # In a real implementation, you would use your data provider API            for sector in sectors:                # Generate random performance (-3% to +3%)                performance = (np.random.random() * 6) - 3                self.sector_performance[sector] = performance                        return True                    except Exception as e:            self.logger.error(f"Error fetching sector performance: {e}")            return False        def fetch_global_indices(self):        """Fetch global market indices"""        try:            self.logger.info("Fetching global market indices")                        # Placeholder global indices            indices = [                "S&P 500", "NASDAQ", "DOW JONES", "FTSE 100",                 "DAX", "NIKKEI 225", "HANG SENG", "SHANGHAI COMPOSITE"            ]                        # In a real implementation, you would use a global market data API            for index in indices:                # Generate random performance (-2% to +2%)                performance = (np.random.random() * 4) - 2                self.global_indices[index] = performance                        return True                    except Exception as e:            self.logger.error(f"Error fetching global indices: {e}")            return False        def fetch_currency_data(self):        """Fetch currency exchange rates"""        try:            self.logger.info("Fetching currency data")                        # Key currency pairs for Indian markets            pairs = ["USD/INR", "EUR/INR", "GBP/INR", "JPY/INR"]                        # In a real implementation, you would use a forex data API            for pair in pairs:                # Generate random rate changes (-1% to +1%)                change = (np.random.random() * 2) - 1                base_rate = 80.0 if pair == "USD/INR" else 90.0                self.fx_rates[pair] = {                    "rate": base_rate * (1 + change/100),                    "change": change                }                        return True                    except Exception as e:            self.logger.error(f"Error fetching currency data: {e}")            return False        def fetch_commodity_prices(self):        """Fetch key commodity prices"""        try:            self.logger.info("Fetching commodity prices")                        # Key commodities for Indian markets            commodities = ["Crude Oil", "Gold", "Silver", "Copper"]                        # In a real implementation, you would use a commodity data API            for commodity in commodities:                # Generate random price changes (-2% to +2%)                change = (np.random.random() * 4) - 2                self.commodities[commodity] = change                        return True                    except Exception as e:            self.logger.error(f"Error fetching commodity prices: {e}")            return False        def fetch_market_news(self, claude_client=None):        """Fetch latest market news and headlines"""        try:            self.logger.info("Fetching market news")                        # In a real implementation, you would use a news API            # This is a placeholder for the actual implementation            self.headlines = [                "RBI maintains repo rate in latest monetary policy meeting",                "IT sector shows strong quarterly results",                "Foreign investors increase holdings in Indian equities",                "Government announces new infrastructure projects",                "Global markets mixed on inflation concerns"            ]                        # If Claude client is provided, analyze the news sentiment            if claude_client:                sentiment = self._analyze_news_sentiment(claude_client)                self.market_state["sentiment"] = sentiment                        return True                    except Exception as e:            self.logger.error(f"Error fetching market news: {e}")            return False        def fetch_economic_calendar(self):        """Fetch upcoming economic events"""        try:            self.logger.info("Fetching economic calendar")                        # In a real implementation, you would use an economic calendar API            # This is a placeholder for the actual implementation            today = datetime.now().date()                        self.economic_calendar = [                {"date": today + timedelta(days=1), "event": "CPI Data Release", "importance": "High"},                {"date": today + timedelta(days=2), "event": "IIP Numbers", "importance": "Medium"},                {"date": today + timedelta(days=5), "event": "RBI Meeting Minutes", "importance": "High"},                {"date": today + timedelta(days=7), "event": "GDP Growth Rate", "importance": "High"}            ]                        return True                    except Exception as e:            self.logger.error(f"Error fetching economic calendar: {e}")            return False        def analyze_market_context(self):        """Analyze the overall market context"""        try:            self.logger.info("Analyzing market context")                        # Analyze trend            self._analyze_trend()                        # Analyze volatility            self._analyze_volatility()                        # Analyze market breadth            self._analyze_market_breadth()                        # Analyze global influence            self._analyze_global_influence()                        # Determine overall market state            self._determine_overall_state()                        self.logger.info(f"Market context analysis complete: {self.market_state['overall']}")            return self.market_state                    except Exception as e:            self.logger.error(f"Error analyzing market context: {e}")            return self.market_state        def get_market_context_for_claude(self):        """Generate a market context summary for Claude's analysis"""        try:            # Create a summary of market conditions            context = f"""            MARKET CONTEXT ANALYSIS            ----------------------            Overall Market State: {self.market_state['overall'].upper()}                        Nifty 50: {self.nifty_data['change']:.2f}% ({self.nifty_data['trend']})            India VIX: {self.vix_data['latest']:.2f} ({self.market_state['volatility']})                        Sector Performance:            {self._format_sector_performance()}                        Global Markets:            {self._format_global_indices()}                        Key Economic Indicators:            - USD/INR: {self.fx_rates.get('USD/INR', {}).get('rate', 0):.2f} ({self.fx_rates.get('USD/INR', {}).get('change', 0):.2f}%)            - Crude Oil: {self.commodities.get('Crude Oil', 0):.2f}%            - Gold: {self.commodities.get('Gold', 0):.2f}%                        Recent Headlines:            {self._format_headlines()}                        Upcoming Economic Events:            {self._format_economic_events()}                        MARKET ANALYSIS SUMMARY:            - Trend: {self.market_state['trend']}            - Volatility: {self.market_state['volatility']}            - Breadth: {self.market_state['breadth']}            - Sentiment: {self.market_state['sentiment']}            - Global Influence: {self.market_state['global_influence']}            """                        return context                    except Exception as e:            self.logger.error(f"Error generating market context for Claude: {e}")            return "Error generating market context."        def _analyze_trend(self):        """Analyze market trend based on moving averages"""        if self.nifty_data is None:            return                try:            df = self.nifty_data['data']                        # Calculate moving averages            df['sma_20'] = df['close'].rolling(window=20).mean()            df['sma_50'] = df['close'].rolling(window=50).mean()            df['sma_200'] = df['close'].rolling(window=200).mean()                        latest = df.iloc[-1]                        # Determine trend based on moving average relationships            if latest['close'] > latest['sma_20'] > latest['sma_50'] > latest['sma_200']:                trend = "strongly_bullish"            elif latest['close'] > latest['sma_50'] > latest['sma_200']:                trend = "bullish"            elif latest['close'] < latest['sma_20'] < latest['sma_50'] < latest['sma_200']:                trend = "strongly_bearish"            elif latest['close'] < latest['sma_50'] < latest['sma_200']:                trend = "bearish"            else:                trend = "neutral"                        self.nifty_data['trend'] = trend            self.market_state['trend'] = trend                    except Exception as e:            self.logger.error(f"Error analyzing trend: {e}")        def _analyze_volatility(self):        """Analyze market volatility based on VIX"""        if self.vix_data is None:            return                try:            latest_vix = self.vix_data['latest']                        # Determine volatility based on VIX levels (adjusted for Indian markets)            if latest_vix > 25:                volatility = "high"            elif latest_vix < 15:                volatility = "low"            else:                volatility = "normal"                        self.market_state['volatility'] = volatility                    except Exception as e:            self.logger.error(f"Error analyzing volatility: {e}")        def _analyze_market_breadth(self):        """Analyze market breadth based on advances vs. declines"""        try:            # In a real implementation, you would get actual advances/declines data            # This is a placeholder            advances = 30  # Number of advancing stocks in Nifty 50            declines = 20  # Number of declining stocks in Nifty 50                        advance_decline_ratio = advances / declines if declines > 0 else float('inf')                        if advance_decline_ratio > 2.0:                breadth = "strongly_positive"            elif advance_decline_ratio > 1.2:                breadth = "positive"            elif advance_decline_ratio < 0.5:                breadth = "strongly_negative"            elif advance_decline_ratio < 0.8:                breadth = "negative"            else:                breadth = "neutral"                        self.market_state['breadth'] = breadth                    except Exception as e:            self.logger.error(f"Error analyzing market breadth: {e}")        def _analyze_global_influence(self):        """Analyze global market influence"""        try:            # Calculate average global market performance            if self.global_indices:                avg_global_perf = sum(self.global_indices.values()) / len(self.global_indices)                                if avg_global_perf > 1.0:                    global_influence = "strongly_positive"                elif avg_global_perf > 0.3:                    global_influence = "positive"                elif avg_global_perf < -1.0:                    global_influence = "strongly_negative"                elif avg_global_perf < -0.3:                    global_influence = "negative"                else:                    global_influence = "neutral"                                self.market_state['global_influence'] = global_influence                    except Exception as e:            self.logger.error(f"Error analyzing global influence: {e}")        def _determine_overall_state(self):        """Determine overall market state based on all factors"""        try:            # Convert states to numeric scores            state_scores = {                "strongly_bullish": 2, "bullish": 1, "neutral": 0, "bearish": -1, "strongly_bearish": -2,                "strongly_positive": 2, "positive": 1, "negative": -1, "strongly_negative": -2,                "high": -1, "normal": 0, "low": 1  # For volatility, high volatility is negative            }                        # Get scores for each factor            trend_score = state_scores.get(self.market_state['trend'], 0)            breadth_score = state_scores.get(self.market_state['breadth'], 0)            volatility_score = state_scores.get(self.market_state['volatility'], 0)            sentiment_score = state_scores.get(self.market_state['sentiment'], 0)            global_score = state_scores.get(self.market_state['global_influence'], 0)                        # Calculate weighted average (trend and breadth matter most)            weights = {"trend": 0.3, "breadth": 0.25, "volatility": 0.15, "sentiment": 0.15, "global": 0.15}            overall_score = (                trend_score * weights["trend"] +                 breadth_score * weights["breadth"] +                volatility_score * weights["volatility"] +                sentiment_score * weights["sentiment"] +                global_score * weights["global"]            )                        # Determine overall state            if overall_score > 1.0:                overall = "strongly_bullish"            elif overall_score > 0.3:                overall = "bullish"            elif overall_score < -1.0:                overall = "strongly_bearish"            elif overall_score < -0.3:                overall = "bearish"            else:                overall = "neutral"                        self.market_state['overall'] = overall                    except Exception as e:            self.logger.error(f"Error determining overall market state: {e}")        def _analyze_news_sentiment(self, claude_client):        """Analyze news sentiment using Claude"""        try:            headlines_text = "\n".join(self.headlines)                        prompt = f"""            As a financial news analyst, evaluate the sentiment of these recent Indian market headlines:                        {headlines_text}                        Based only on these headlines, what is the overall market sentiment?             Respond with exactly one word: "strongly_positive", "positive", "neutral", "negative", or "strongly_negative".            """                        message = claude_client.messages.create(                model="claude-3-7-sonnet-20250219",                max_tokens=10,                temperature=0,                system="You are a financial news sentiment analyzer. Respond with exactly one sentiment word as instructed.",                messages=[                    {"role": "user", "content": prompt}                ]            )                        sentiment = message.content[0].text.strip().lower()                        # Validate the response            valid_sentiments = ["strongly_positive", "positive", "neutral", "negative", "strongly_negative"]            if sentiment not in valid_sentiments:                sentiment = "neutral"                        return sentiment                    except Exception as e:            self.logger.error(f"Error analyzing news sentiment: {e}")            return "neutral"        def _generate_placeholder_index_data(self, index_name):        """Generate placeholder data for an index"""        # This would be replaced with actual API calls in production        end_date = datetime.now()        start_date = end_date - timedelta(days=365)        dates = pd.date_range(start=start_date, end=end_date, freq='B')                # Generate random price data        np.random.seed(42)  # For reproducibility                if index_name == "INDIA VIX":            # VIX is typically between 10-30            latest = np.random.uniform(10, 30)            return {                "name": index_name,                "latest": latest,                "change": np.random.uniform(-5, 5)            }                # For price indices        base_price = 18000 if index_name == "NIFTY 50" else 40000        closes = [base_price]                # Generate random walk        for i in range(1, len(dates)):            daily_return = np.random.normal(0.0003, 0.01)  # Mean and std dev            closes.append(closes[-1] * (1 + daily_return))                df = pd.DataFrame({            'date': dates,            'close': closes        })                # Generate OHLC based on close        df['open'] = df['close'].shift(1) * (1 + np.random.normal(0, 0.003, len(df)))        df['high'] = df[['open', 'close']].max(axis=1) * (1 + abs(np.random.normal(0, 0.002, len(df))))        df['low'] = df[['open', 'close']].min(axis=1) * (1 - abs(np.random.normal(0, 0.002, len(df))))        df['volume'] = np.random.uniform(1000000, 5000000, len(df))                # Calculate change        latest_close = df['close'].iloc[-1]        prev_close = df['close'].iloc[-2]        change = ((latest_close / prev_close) - 1) * 100                return {            "name": index_name,            "data": df,            "latest": latest_close,            "change": change,            "trend": "neutral"  # Will be updated during analysis        }        def _format_sector_performance(self):        """Format sector performance for display"""        if not self.sector_performance:            return "No sector data available"                    formatted = ""        for sector, perf in self.sector_performance.items():            formatted += f"- {sector}: {perf:.2f}%\n"                return formatted        def _format_global_indices(self):        """Format global indices for display"""        if not self.global_indices:            return "No global market data available"                    formatted = ""        for index, perf in self.global_indices.items():            formatted += f"- {index}: {perf:.2f}%\n"                return formatted        def _format_headlines(self):        """Format headlines for display"""        if not self.headlines:            return "No recent headlines available"                    formatted = ""        for headline in self.headlines:            formatted += f"- {headline}\n"                return formatted        def _format_economic_events(self):        """Format economic events for display"""        if not self.economic_calendar:            return "No upcoming economic events"                    formatted = ""        for event in self.economic_calendar:            formatted += f"- {event['date'].strftime('%d %b')}: {event['event']} (Importance: {event['importance']})\n"                return formatted